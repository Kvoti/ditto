define(["exports", "module", "react", "vendor/react-bootstrap/index"], function (exports, module, _react, _vendorReactBootstrapIndex) {
			"use strict";

			var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

			var React = _interopRequire(_react);

			// TODO prob only load components we need?
			var Bootstrap = _vendorReactBootstrapIndex;
			// TODO shouldn't this work without /index?

			var connection;
			var composedMessageChangeAt;
			var stillTypingTimeout = 5000;
			var chatStatus = {
						away: "Away",
						chat: "Free for chat",
						dnd: "Do not disturb",
						xa: "Extended away" };
			var update = React.addons.update;
			var classSet = React.addons.classSet;
			var ReactCSSTransitionGroup = React.addons.CSSTransitionGroup;

			var getMessages = function getMessages(messages, other) {
						return messages.filter(function (msg) {
									return msg.from === other || msg.to === other;
						});
			};

			var Chat = React.createClass({
						displayName: "Chat",

						getInitialState: function getInitialState() {
									return {
												connectionStatus: "connecting",
												talkingTo: Strophe.getNodeFromJid(this.props.other || ""),
												friends: [],
												friendStatus: {},
												messages: [],
												chatroomMessages: [],
												userMeta: {},
												whosTyping: [],
												chatroomPresence: [] };
						},
						getBareJID: function getBareJID(node) {
									var domain = Strophe.getDomainFromJid(this.props.me);
									return node + "@" + domain;
						},
						componentDidMount: function componentDidMount() {
									this.connectToChatServer();
						},
						connectToChatServer: function connectToChatServer() {
									connection = new Strophe.Connection("ws://" + this.props.server + ":5280/ws-xmpp");
									if (this.props.hasOwnProperty("log")) {
												connection.rawInput = function (data) {
															console.log("RECV: ", data);
												};
												connection.rawOutput = function (data) {
															console.log("RECV: ", data);
												};
									}
									var self = this; // TODO better way these days?
									connection.connect(this.props.me, this.props.password, function (status) {
												self.onConnect(connection, status);
									});
						},
						onConnect: function onConnect(connection, status_code) {
									var status;
									if (status_code == Strophe.Status.CONNECTING) {
												status = "connecting";
									} else if (status_code == Strophe.Status.CONNFAIL) {
												status = "failed to connect";
									} else if (status_code == Strophe.Status.DISCONNECTING) {
												status = "disconnecting";
									} else if (status_code == Strophe.Status.DISCONNECTED) {
												status = "disconnected";
									} else if (status_code == Strophe.Status.CONNECTED) {
												status = "connected";

												connection.send($pres().tree());
												connection.addHandler(this.handlePrivateMessage, null, "message", "chat", null);
												connection.addHandler(this.handlePresence, null, "presence", null, null);

												connection.mam.init(connection);
												connection.mam.query(Strophe.getBareJidFromJid(this.props.me), {
															// TODO load last N messages for each chat not across all chats
															// 'with': Strophe.getBareJidFromJid(this.state.talkingTo),
															before: "",
															max: 50,
															onMessage: this.handleArchivedPrivateMessage
												});

												connection.roster.init(connection);
												connection.roster.registerRequestCallback(this.acceptFriendRequest);
												connection.roster.registerCallback(this.handleRoster);
												connection.roster.subscribe(this.getBareJID(this.state.talkingTo));
												connection.roster.get();

												connection.vcard.init(connection);
												this.getUserMeta(Strophe.getNodeFromJid(this.props.me));

												connection.chatstates.init(connection);

												connection.muc.init(connection);
												connection.muc.join(this.props.chatroom, this.props.nick, this.handleGroupMessage, this.handleGroupPresence);
									}
									this.setState({ connectionStatus: status });
						},
						switchChat: function switchChat(friend) {
									this.setState({
												talkingTo: friend });
						},
						handlePresence: function handlePresence(pres) {
									var msg = $(pres);
									var from = Strophe.getNodeFromJid(msg.attr("from"));
									var type = msg.attr("type");
									var code;
									var customMessage;
									var newState;
									var status;
									var friendStatus = {};

									if (type === "unavailable") {
												status = {};
									} else {
												code = msg.find("show").text();
												customMessage = msg.find("status").text();
												status = {
															code: code,
															message: customMessage
												};
									}
									friendStatus[from] = { $set: status };
									this.setState(update(this.state, { friendStatus: friendStatus }));
									return true;
						},
						setMyStatus: function setMyStatus(code, message) {
									console.log("setting status", code, message);
									var pres = $pres();
									if (code) {
												pres.c("show").t(code).up();
									}
									if (message) {
												pres.c("status").t(message);
									}
									connection.send(pres.tree());
						},
						handleArchivedPrivateMessage: function handleArchivedPrivateMessage(msg) {
									var msg = $(msg);
									if (msg.find("[type=groupchat]").length === 0) {
												var body = msg.find("body:first").text();
												var from = Strophe.getNodeFromJid(msg.find("message").attr("from"));
												var to = Strophe.getNodeFromJid(msg.find("message").attr("to"));
												var when = new Date(msg.find("delay").attr("stamp"));
												this.addMessage(from, to, when, body);
									}
									return true;
						},
						handlePrivateMessage: function handlePrivateMessage(msg) {
									var msg = $(msg);
									var body = msg.find("body:first").text();
									var from = Strophe.getNodeFromJid(msg.attr("from"));
									var to = Strophe.getNodeFromJid(msg.attr("to"));
									var when = new Date();
									var composing = msg.find("composing");
									var active = msg.find("active");
									var newState;

									if (composing.length) {
												newState = update(this.state, { whosTyping: { $push: [from] } });
												this.setState(newState);
									} else {
												if (active.length) {
															newState = update(this.state, { whosTyping: { $splice: [[this.state.whosTyping.indexOf(from), 1]] } });
															this.setState(newState);
												}
												if (body) {
															if (this.props.page !== "messages" || this.isPageHidden()) {
																		this.notifyNewMessage(body);
															}
															this.addMessage(from, to, when, body);
												}
									}
									return true;
						},
						isPageHidden: function isPageHidden() {
									// TODO keep this kind of things to existing polyfills (loaded with modernizr?)?
									return document.hidden || document.webkitHidden || document.mozHidden || document.msHidden;
						},
						notifyNewMessage: function notifyNewMessage(msg) {
									console.log("playing beep");
									document.getElementById("new-message-beep").play();
									var notification = new Notification("New message", {
												icon: "/static/images/ditto-logo.png",
												body: msg.slice(0, 140)
									});
									// TODO this is supposed to go to the right tab in chrome but doesn't seem to work
									notification.onclick = function () {
												window.focus();
									};
						},
						handleGroupMessage: function handleGroupMessage(msg) {
									var msg = $(msg);
									var body = msg.find("body:first").text();
									var from = Strophe.getResourceFromJid(msg.attr("from"));
									var when = msg.find("delay");
									if (when.length) {
												when = new Date(when.attr("stamp"));
									} else {
												when = new Date();
									}
									if (from) {
												// TODO always get an 'empty' message from the room
												// itself, not sure why
												this.addGroupMessage(from, when, body);
									}
									return true;
						},
						handleGroupPresence: function handleGroupPresence(pres) {
									var msg = $(pres);
									var nick_taken = msg.find("conflict");
									var from = msg.attr("from").split("/")[1];
									var newState;
									if (nick_taken.length) {}
									var added = msg.find("item[role!=none]");
									if (added.length) {
												newState = update(this.state, { chatroomPresence: { $splice: [[0, 0, from]] } });
									}
									var removed = msg.find("item[role=none]");
									if (removed.length) {
												newState = update(this.state, { chatroomPresence: { $splice: [[this.state.chatroomPresence.indexOf(from), 1]] } });
									}
									// First time we enter the chatroom for a new network the room
									// needs to be created and configured
									var is_new_room = msg.find("status[code=201]");
									if (is_new_room.length) {
												// TODO handle failure
												connection.muc.createInstantRoom(this.props.chatroom);
									}
									this.setState(newState);
									return true;
						},
						handleMessageSubmit: function handleMessageSubmit(message) {
									if (this.props.page === "chatroom") {
												connection.muc.groupchat(this.props.chatroom, message);
									} else {
												var payload = $msg({
															to: this.getBareJID(this.state.talkingTo),
															from: this.props.me,
															type: "chat"
												}).c("body").t(message);

												connection.chatstates.addActive(payload);
												composedMessageChangeAt = null;

												connection.send(payload.tree());
												// TODO functions have kwargs in es6?
												// TODO handle error on message submit
												this.addMessage(Strophe.getNodeFromJid(this.props.me), this.state.talkingTo, new Date(), message);
									}
						},
						handleMessageChange: function handleMessageChange() {
									if (!composedMessageChangeAt) {
												connection.chatstates.sendComposing(this.getBareJID(this.state.talkingTo));
												composedMessageChangeAt = new Date();
												setTimeout(this.checkImStillTyping, stillTypingTimeout);
									}
						},
						checkImStillTyping: function checkImStillTyping() {
									if (composedMessageChangeAt) {
												var now = new Date();
												if (now - composedMessageChangeAt > stillTypingTimeout) {
															composedMessageChangeAt = undefined;
															connection.chatstates.sendActive(this.getBareJID(this.state.talkingTo));
												} else {
															window.setTimeout(this.checkImStillTyping, stillTypingTimeout);
												}
									}
						},
						acceptFriendRequest: function acceptFriendRequest(from) {
									connection.roster.authorize(from);
									return true;
						},
						handleRoster: function handleRoster(roster, item) {
									var friends = [];
									var newState;
									var self = this;
									$.each(roster, function (i, friend) {
												var username = Strophe.getNodeFromJid(friend.jid);
												if (friend.subscription === "both") {
															friends.push(username);
															self.getUserMeta(username);
												}
									});
									newState = update(this.state, { friends: { $set: friends } });
									if (!this.state.talkingTo && friends) {
												newState = update(newState, { talkingTo: { $set: friends[0] } });
									}
									this.setState(newState);
									return true; // always bloody forget this!
						},
						getUserMeta: function getUserMeta(user) {
									var _this = this;

									var jid = this.getBareJID(user);
									if (this.state.userMeta[user]) {
												return;
									}
									connection.vcard.get(function (vcard) {
												vcard = $(vcard);
												var setUserMeta = {};
												var newState;
												var role = vcard.find("ROLE").text();
												var avatar = vcard.find("PHOTO").text();
												setUserMeta[user] = { $set: { role: role, avatar: avatar } };
												newState = update(_this.state, { userMeta: setUserMeta });
												_this.setState(newState);
									}, jid);
						},
						addMessage: function addMessage(from, to, when, message) {
									var newState;
									newState = update(this.state, { messages: {
															$push: [{
																		from: from,
																		to: to,
																		when: when,
																		message: message
															}]
												} });
									this.setState(newState);
						},
						addGroupMessage: function addGroupMessage(from, when, message) {
									var newState;
									newState = update(this.state, { chatroomMessages: {
															$push: [{
																		from: from,
																		when: when,
																		message: message
															}]
												} });
									this.setState(newState);
						},
						render: function render() {
									var messages;
									if (!this.props.page) {
												// For now we have some pages with no chat UI elements but
												// we're still connected to chat so we can, for example, beep
												// on new messages. TODO maybe that should be separated out
												// from the react stuff?
												return React.createElement("div", null);
									} else if (this.state.connectionStatus !== "connected") {
												return React.createElement(
															"div",
															null,
															this.state.connectionStatus
												);
									} else if (this.props.page === "chatroom") {
												return React.createElement(
															"div",
															{ className: "row" },
															React.createElement(
																		"div",
																		{ className: "col-md-8" },
																		React.createElement(Messages, { me: Strophe.getNodeFromJid(this.props.me), talkingTo: this.state.talkingTo, messages: this.state.chatroomMessages, userMeta: this.state.userMeta }),
																		React.createElement(
																					"div",
																					{ className: "row msgbar" },
																					React.createElement(ComposeMessage, { onMessageSubmit: this.handleMessageSubmit, onMessageChange: this.handleMessageChange })
																		)
															),
															React.createElement(
																		"div",
																		{ className: "col-md-4" },
																		React.createElement(ChatroomPresence, { users: this.state.chatroomPresence })
															)
												);
									} else if (this.props.page === "messages") {
												messages = getMessages(this.state.messages, this.state.talkingTo);
												return React.createElement(
															"div",
															{ className: "row" },
															React.createElement(
																		"div",
																		{ className: "col-md-4" },
																		React.createElement(
																					"div",
																					{ className: "list-group" },
																					React.createElement(Friends, { messages: this.state.messages, friends: this.state.friends, friendStatus: this.state.friendStatus, current: this.state.talkingTo, switchChat: this.switchChat, userMeta: this.state.userMeta })
																		)
															),
															React.createElement(
																		"div",
																		{ className: "col-md-8" },
																		React.createElement(Messages, { me: Strophe.getNodeFromJid(this.props.me), talkingTo: this.state.talkingTo, messages: messages, userMeta: this.state.userMeta }),
																		React.createElement(WhosTyping, { users: this.state.whosTyping }),
																		React.createElement(
																					"div",
																					{ className: "row msgbar" },
																					React.createElement(ComposeMessage, { onMessageSubmit: this.handleMessageSubmit, onMessageChange: this.handleMessageChange }),
																					React.createElement(MyStatus, { setStatus: this.setMyStatus })
																		)
															)
												);
									} else {
												return React.createElement(WhosOnline, { users: this.state.chatroomPresence, userMeta: this.state.userMeta });
									}
						}
			});

			var WhosOnline = React.createClass({
						displayName: "WhosOnline",

						usersPerPanel: 9,
						groupUsers: function groupUsers(users) {
									var _this = this;

									var grouped = [];
									var group;
									users.forEach(function (user, i) {
												if (i % _this.usersPerPanel === 0) {
															group = [];
															grouped.push(group);
												}
												group.push(user);
									});
									return grouped;
						},
						render: function render() {
									var _this = this;

									var userMeta = this.props.userMeta;
									var groupedUsers = this.groupUsers(this.props.users);
									var items = groupedUsers.map(function (group, i) {
												return React.createElement(
															Bootstrap.CarouselItem,
															{ key: i },
															React.createElement(WhosOnlineItem, { users: group, userMeta: _this.props.userMeta, key: i })
												);
									});
									return React.createElement(
												"div",
												{ className: "row" },
												React.createElement(
															"div",
															{ className: "col-md-4 whosonline" },
															React.createElement(
																		Bootstrap.Carousel,
																		{ interval: false },
																		items
															)
												)
									);
						}
			});

			var WhosOnlineItem = React.createClass({
						displayName: "WhosOnlineItem",

						render: function render() {
									var _this = this;

									var users = this.props.users.map(function (user, i) {
												return React.createElement(
															"div",
															{ className: "avatar", key: i },
															React.createElement(Avatar, { size: 100, user: user, userMeta: _this.props.userMeta }),
															React.createElement(
																		"p",
																		null,
																		user
															)
												);
									});
									return React.createElement(
												"div",
												null,
												users
									);
						}
			});

			var ChatroomPresence = React.createClass({
						displayName: "ChatroomPresence",

						render: function render() {
									var memberNodes = this.props.users.map(function (user) {
												return React.createElement(
															"li",
															{ className: "list-group-item", key: user },
															React.createElement(
																		"div",
																		{ className: "media" },
																		React.createElement("div", { className: "media-left media-middle" }),
																		React.createElement(
																					"div",
																					{ className: "media-body" },
																					React.createElement(
																								"h4",
																								{ className: "media-heading" },
																								user
																					)
																		)
															)
												);
									});
									return React.createElement(
												"ul",
												{ className: "list-group" },
												memberNodes
									);
						}
			});

			var MyStatus = React.createClass({
						displayName: "MyStatus",

						getInitialState: function getInitialState() {
									return {
												status: "",
												message: "" };
						},
						handleMessageChange: function handleMessageChange(event) {
									this.setState({ message: event.target.value });
						},
						handleStatusChange: function handleStatusChange(e) {
									e.preventDefault();
									var message = this.refs.message.getDOMNode().value.trim();
									var code = this.refs.status.getDOMNode().value;
									this.props.setStatus(code, message);
						},
						render: function render() {
									var options = [];
									for (var code in chatStatus) {
												options.push(React.createElement(
															"option",
															{ value: code, key: code },
															chatStatus[code]
												));
									}
									return React.createElement(
												"form",
												{ onSubmit: this.handleStatusChange },
												React.createElement(
															"div",
															{ className: "col-md-2" },
															React.createElement("input", { className: "form-control", value: this.state.message, onChange: this.handleMessageChange, type: "text", placeholder: "Type your custom status message here...", ref: "message" })
												),
												React.createElement(
															"div",
															{ className: "col-md-2" },
															React.createElement(
																		"select",
																		{ className: "form-control", ref: "status" },
																		React.createElement(
																					"option",
																					{ value: "" },
																					"Online"
																		),
																		options
															)
												),
												React.createElement(
															"div",
															{ className: "col-md-1" },
															React.createElement("input", { className: "form-control btn btn-success", type: "submit", value: "Set status" })
												)
									);
						}
			});

			var Friends = React.createClass({
						displayName: "Friends",

						render: function render() {
									var self = this;
									var friendNodes = this.props.friends.map(function (friend, index) {
												var isCurrent = self.props.current === friend;
												var status = self.props.friendStatus[friend];
												var lastMessage = getMessages(self.props.messages, friend).pop();
												return React.createElement(Friend, { isCurrent: isCurrent, friend: friend, status: status, lastMessage: lastMessage, key: index, switchChat: self.props.switchChat, userMeta: self.props.userMeta });
									});
									return React.createElement(
												"div",
												null,
												friendNodes
									);
						}
			});

			var Friend = React.createClass({
						displayName: "Friend",

						switchChat: function switchChat(e) {
									e.preventDefault();
									this.props.switchChat(this.props.friend);
						},
						render: function render() {
									var current,
									    status = "",
									    lastMessage;
									if (this.props.isCurrent) {
												current = React.createElement(
															"span",
															null,
															" * "
												);
									}
									if (this.props.status && this.props.status.hasOwnProperty("code")) {
												status = React.createElement(FriendStatus, { code: this.props.status.code, message: this.props.status.message });
									} else {
												status = React.createElement(
															"p",
															null,
															"Offline"
												);
									}
									return React.createElement(
												"a",
												{ className: "list-group-item", href: "#", onClick: this.switchChat },
												React.createElement(
															"div",
															{ className: "media-left media-middle friends-avatar" },
															React.createElement(Avatar, { size: 50, user: this.props.friend, userMeta: this.props.userMeta })
												),
												React.createElement(
															"div",
															{ className: "media-body" },
															React.createElement(
																		"h4",
																		{ className: "media-heading friends-username" },
																		current,
																		" ",
																		this.props.friend
															),
															status,
															React.createElement(LastMessage, { message: this.props.lastMessage })
												)
									);
						}
			});

			var LastMessage = React.createClass({
						displayName: "LastMessage",

						render: function render() {
									if (this.props.message) {
												return React.createElement(
															"div",
															null,
															this.props.message.message,
															" ",
															React.createElement(
																		"small",
																		null,
																		React.createElement(Timestamp, { when: this.props.message.when })
															)
												);
									} else {
												return React.createElement("div", null); // TODO empty component a thing?
									}
						}
			});

			var FriendStatus = React.createClass({
						displayName: "FriendStatus",

						render: function render() {
									var status = chatStatus[this.props.code] || "Online";
									return React.createElement(
												"p",
												null,
												status,
												" ",
												React.createElement(
															"em",
															null,
															this.props.message
												)
									);
						}
			});

			var Chatroom = React.createClass({
						displayName: "Chatroom",

						render: function render() {
									var current;
									if (this.props.isInside) {
												current = React.createElement(
															"span",
															null,
															" * "
												);
									}
									return React.createElement(
												"a",
												{ className: "list-group-item", onClick: this.props.show, href: "#" },
												current,
												" Chatroom"
									);
						}
			});

			var Messages = React.createClass({
						displayName: "Messages",

						getInitialState: function getInitialState() {
									return { height: "" };
						},
						componentDidMount: function componentDidMount() {
									// TODO window.onresize cross-browser?
									window.onresize = this.updateHeight;
						},
						updateHeight: function updateHeight() {
									// TODO no pure css way to do this?
									// Note, tried to calculate the height from other dom elements but it's easier just to hardcode this vaule and change it when the css changes
									var height = $(window).height() - 160;
									debugger;
									this.setState({ height: height });
						},
						componentWillMount: function componentWillMount() {
									this.updateHeight();
						},
						componentWillUnmount: function componentWillUnmount() {},
						componentDidUpdate: function componentDidUpdate() {
									var node = this.getDOMNode();
									node.scrollTop = node.scrollHeight;
						},
						render: function render() {
									var userMeta = this.props.userMeta;
									var self = this;
									var messageNodes = this.props.messages.map(function (m, i) {
												// TODO this key should be unique across all messages, how do I do that?
												return React.createElement(Message, { me: self.props.me, from: m.from, to: m.to, message: m.message, when: m.when, userMeta: userMeta, key: m.when });
									});
									var style = { height: this.state.height };
									return React.createElement(
												"div",
												{ style: style, id: "msgs", ref: "messages" },
												React.createElement(
															ReactCSSTransitionGroup,
															{ transitionName: "example" },
															messageNodes
												)
									);
						}
			});

			var Message = React.createClass({
						displayName: "Message",

						render: function render() {
									var left_avatar, right_avatar;
									var is_from_me = this.props.from === this.props.me;
									var mediaClass = classSet({
												"media-left": !is_from_me,
												"media-right": is_from_me
									});
									var avatar = React.createElement(
												"div",
												{ className: mediaClass },
												React.createElement(Avatar, { size: 50, user: this.props.from, userMeta: this.props.userMeta })
									);
									var colClass = classSet({
												"col-md-6": true,
												"col-md-offset-6": is_from_me
									});
									if (is_from_me) {
												right_avatar = avatar;
									} else {
												left_avatar = avatar;
									}
									return React.createElement(
												"div",
												{ className: "row" },
												React.createElement(
															"div",
															{ className: colClass },
															React.createElement(
																		"div",
																		{ className: "media" },
																		left_avatar,
																		React.createElement(
																					"div",
																					{ className: "media-body" },
																					React.createElement(
																								"h4",
																								{ className: "media-heading" },
																								this.props.from,
																								" ",
																								React.createElement(
																											"small",
																											null,
																											React.createElement(Timestamp, { when: this.props.when })
																								)
																					),
																					this.props.message
																		),
																		right_avatar
															)
												)
									);
						}
			});

			var WhosTyping = React.createClass({
						displayName: "WhosTyping",

						render: function render() {
									var nodes = this.props.users.map(function (user, i) {
												return React.createElement(
															"p",
															{ key: i },
															user,
															" is typing ..."
												);
									});
									return React.createElement(
												"div",
												null,
												nodes
									);
						}
			});

			var Avatar = React.createClass({
						displayName: "Avatar",

						render: function render() {
									// TODO where to put global constant state like this?
									var avatarSVGs = $("#avatar_svgs").text();
									var avatarName;
									var meta = this.props.userMeta[Strophe.getBareJidFromJid(this.props.user)];
									if (meta) {
												avatarName = meta.avatar;
									} else {
												avatarName = "cupcake";
									}
									// TODO better way to generate svg without jquery/outerHTML, convert svg to react component?
									var avatarSVG = $(avatarSVGs);
									if (avatarName) {
												avatarSVG.find(">g[id!=" + avatarName + "]").remove();
												avatarSVG.find(">g").show();
												avatarSVG.attr({
															width: this.props.size,
															height: this.props.size
												});
												avatarSVG = avatarSVG.get(0).outerHTML;
									} else {
												avatarSVG = "";
									}
									return React.createElement(
												"div",
												{ className: "avatar" },
												React.createElement("div", { dangerouslySetInnerHTML: { __html: avatarSVG } })
									);
						}
			});

			var Timestamp = React.createClass({
						displayName: "Timestamp",

						componentDidMount: function componentDidMount() {
									this.interval = setInterval(this.updateDelta, 60 * 1000);
						},
						componentWillUnmount: function componentWillUnmount() {
									clearInterval(this.interval);
						},
						updateDelta: function updateDelta() {
									// TODO this doesn't feel right
									this.setState({});
						},
						// TODO prob library for this
						timeAgo: function timeAgo(date) {
									var delta = new Date() - date;
									if (delta < 60000) {
												return "less than a minute ago";
									}
									if (delta < 3600 * 1000) {
												var minutes = delta / (60 * 1000);
												return Math.floor(minutes) + " minutes ago";
									}
									if (delta < 2 * 3600 * 1000) {
												return "about an hour ago";
									}
									return "ages ago";
						},
						render: function render() {
									var when = this.props.when;
									var delta = this.timeAgo(when);
									return React.createElement(
												"time",
												{ dateTime: when.toISOString() },
												delta
									);
						}
			});

			var ComposeMessage = React.createClass({
						displayName: "ComposeMessage",

						getInitialState: function getInitialState() {
									return { value: "" };
						},
						handleChange: function handleChange(event) {
									this.setState({ value: event.target.value });
									this.props.onMessageChange();
						},
						handleSubmit: function handleSubmit(e) {
									e.preventDefault();
									var message = this.refs.message.getDOMNode().value.trim();
									if (!message) {
												return;
									}
									this.props.onMessageSubmit(message);
									this.setState({ value: "" });
									return;
						},
						render: function render() {
									return React.createElement(
												"form",
												{ onSubmit: this.handleSubmit },
												React.createElement(
															"div",
															{ className: "col-md-6" },
															React.createElement("input", { className: "form-control", value: this.state.value, onChange: this.handleChange, type: "text", placeholder: "Type your message here...", ref: "message" })
												),
												React.createElement(
															"div",
															{ className: "col-md-1" },
															React.createElement("input", { className: "btn btn-success", type: "submit", value: "Say it!" })
												)
									);
						}
			});

			var render = function render() {
						React.render(React.createElement(Chat, { server: chatConf.server, me: chatConf.me, password: chatConf.password, other: chatConf.other, chatroom: chatConf.chatroom, nick: chatConf.nick, page: chatConf.page }), document.getElementById(chatConf.element));
			};
			module.exports = render;
});

// TODO do something with this

// TODO window.remove event listener
//# sourceMappingURL=chat2.min.js.map